{"version":3,"file":"component---src-pages-writings-philosophy-of-rpc-js-1ff619ba10dd278692cd.js","mappings":"wKAuCA,MAnCmBA,IAWZ,IAXa,QAClBC,EAAO,aACPC,EAAa,GAAE,UACfC,EAAU,GAAE,cACZC,EAAa,QACbC,EAAO,UACPC,EAAU,GAAE,UACZC,EAAU,GAAE,iBACZC,EAAiB,GAAE,GACnBC,EAAG,GAAE,SACLC,GACDV,EACC,OACEW,EAAAA,cAAA,OAAKJ,UAAWA,EAAWE,GAAIA,GAC7BE,EAAAA,cAAA,OAAKJ,UAAW,GAAGK,EAAAA,EAAUC,KAAKC,yCAChCH,EAAAA,cAAA,OAAKJ,UAAW,GAAGJ,KACjBQ,EAAAA,cAAA,MAAIJ,UAAW,GAAGL,KACfD,GAEFS,GAEFL,GAAWD,EACVO,EAAAA,cAAA,OAAKJ,UAAW,GAAGD,KAChBD,EACCM,EAAAA,cAACI,EAAAA,EAAI,CAACC,KAAMX,EAASE,UAAWC,IAEhCJ,GAGH,MAED,C,0ECkJV,UAxKca,IACZ,MAAM,EAACC,EAAc,EAACC,IAAcC,EAAAA,EAAAA,WAAS,GAQ7C,OACET,EAAAA,cAACU,EAAAA,EAAM,CAACC,YAAY,IAClBX,EAAAA,cAACY,EAAAA,EAAG,CACFC,MAAM,oBACNC,YAAa,yHAEfd,EAAAA,cAAA,OACEe,MAAM,eACNC,MAAO,CACLC,UAAW,UAGbjB,EAAAA,cAACkB,EAAAA,EAAU,CACT5B,QAAQ,oBACRC,aAAa,2CACbC,UAAU,uBACVI,UAAU,SAEZI,EAAAA,cAAA,OAAKJ,UAAU,4BACbI,EAAAA,cAAA,OAAKJ,UAAU,eACbI,EAAAA,cAAA,KAAGJ,UAAU,yCAAwC,iKAInDI,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,+QAMNA,EAAAA,cAAA,WAAM,+LAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,ggBASNA,EAAAA,cAAA,WAAM,0FAGNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,+TAMNA,EAAAA,cAAA,WAAM,uhBAUNA,EAAAA,cAAA,WAAM,sDAENA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,ouBAaNA,EAAAA,cAAA,WAAM,4NAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,0KAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WACAA,EAAAA,cAAA,SAAI,0BAA6B,kEAE/BA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,8LAIRA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,sKAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,yMAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,0KAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WACAA,EAAAA,cAAA,SAAI,2BAA8B,+RAMlCA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,kOAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,8KAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,uOAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,iMAKNA,EAAAA,cAAA,WAAM,+BAENA,EAAAA,cAAA,WACAA,EAAAA,cAAA,eAKD,C","sources":["webpack://pjay.in/./src/components/home/SectionBox.js","webpack://pjay.in/./src/pages/writings/philosophy-of-rpc.js"],"sourcesContent":["import React from \"react\";\nimport Icon from \"../Icon\";\nimport styleVars from \"../../styles/style-vars\";\n\nconst SectionBox = ({\n  heading, \n  headingClass=\"\", \n  bodyClass=\"\", \n  sideComponent,\n  sideImg, \n  sideClass=\"\", \n  className=\"\",\n  sideImgClassName=\"\",\n  id=\"\",\n  children\n}) => {\n  return (\n    <div className={className} id={id}>\n      <div className={`${styleVars.page.xl} grid-12 gutter-row-20 gutter-36-ns`}>\n        <div className={`${bodyClass}`}>\n          <h1 className={`${headingClass}`}>\n            {heading}\n          </h1>\n          {children}\n        </div>\n        {sideImg || sideComponent ? (\n          <div className={`${sideClass}`}>\n            {sideImg ? (\n              <Icon name={sideImg} className={sideImgClassName}/>\n            ) : (\n              sideComponent\n            )}\n          </div>\n        ): null}\n      </div>\n    </div>\n  );\n}\n\nexport default SectionBox;\n","import React, { useState } from \"react\";\nimport Layout from \"../../components/layout/index\";\nimport SEO from \"../../components/seo\";\nimport { SectionBox } from \"../../components/home\";\n\nconst handleScroll = (isModalOpen) => {\n  if (isModalOpen === true) {\n    document.documentElement.style.overflow = \"hidden\";\n  } else {\n    document.documentElement.style.overflowY = \"scroll\";\n  }\n};\n\nconst Page = (props) => {\n  const [isContactOpen, setContact] = useState(false);\n  const handleContact = () => {\n    // Look into state updates\n    // Look into state updates\n    handleScroll(!isContactOpen);\n    setContact(!isContactOpen);\n  };\n\n  return (\n    <Layout headerClass=\"\">\n      <SEO\n        title=\"Philosophy of RPC\"\n        description={`Philosophy of RPC - A deep dive into the principles of Remote Procedure Call (RPC) and how it has evolved over time.`}\n      />\n      <div\n        class=\"main-content\"\n        style={{\n          minHeight: \"100vh\",\n        }}\n      >\n        <SectionBox\n          heading=\"Philosophy of RPC\"\n          headingClass=\"ma0 pa0 f2 f-headline-ns sig-blue fw-600\"\n          bodyClass=\"col-12 mw-100 center\"\n          className=\"pt16\"\n        />\n        <div className=\" pt0 pb5 pt10-ns pb20-ns\">\n          <div className=\"mw-l center\">\n            <p className=\"ma0 pa0 pl5 pr5 mt4 f4 f3-ns sig-grey\">\n              We know distributed systems as a collection of nodes (machines)\n              that communicate with each other over a network. These nodes can\n              be servers, clients, or both.\n              <br />\n              <br />\n              Imagine you’re a developer at CoolStuff Inc., an online store\n              selling gadgets. One day, your team needs to add credit card\n              payments. But wait—the payment process isn’t handled by CoolStuff.\n              Instead, you need to call a third-party payment service like\n              Stripe or PayPal.\n              <br />\n              So what happens when a user wants to pay with a credit card? The\n              user enters their card details on CoolStuff’s website, and\n              CoolStuff needs to send this information to the payment service.\n              <br />\n              <br />\n              Essentially, CoolStuff needs to send a message to the payment\n              service, which is running on a different node owned by another\n              company. This message contains the credit card number and the\n              amount to be charged. The payment service then does a whole bunch\n              of things—validating the card, communicating with the credit card\n              network and the bank to authorize the transaction, and finally,\n              sending a response back to CoolStuff. Based on this response,\n              CoolStuff updates the order status to either “paid” or “failed.”\n              <br />\n              This is an example of distributed systems that is used every day\n              by millions of people.\n              <br />\n              <br />\n              Let's look at a bit at what the code might look like. You are\n              developing the software that runs on CoolStuff’s server, and\n              someone else is developing the software that runs on the payment\n              service’s server and provides you a procedure to call to make the\n              payment. Let’s call this procedure or function `make_payment`.\n              <br />\n              When you call `make_payment` function, you don’t know what happens\n              underneath. You don’t know how the payment service is implemented,\n              but it will have a network communication layer that will send the\n              message to the payment service. So underneath, the `make_payment`\n              function will translate Coolstuff message to a format that the\n              payment service understands, send it over the network, and wait\n              for the response. When the response comes back, it will translate\n              the response to a format that CoolStuff understands and return it\n              to you.\n              <br />\n              This is the essence of Remote Procedure Call (RPC).\n              <br />\n              <br />\n              So let's have a look at the how a typical RPC call work. RPC is\n              typically implemented using a client-server model. The client is\n              the one that initiates the RPC call and the server is the one that\n              receives the call and executes the procedure. The client and\n              server can be on the same machine or on different machines. The\n              client and server can be implemented in different languages and\n              can run on different operating systems. The client and server\n              communicate over a network using a protocol like HTTP, TCP, or\n              UDP. The client sends a message to the server, the server executes\n              the procedure, and sends a response back to the client. The client\n              waits for the response and when it receives the response, it\n              continues executing the program.\n              <br />\n              So essentially RPC is about calling a function and that causes\n              something to happen on a remote server by making some network\n              request and packaging the whole thing into a function implemented\n              in a programming language.\n              <br />\n              <br />\n              RPC’s core philosophy: to hide the complexity of distributed\n              systems. By mimicking local programming paradigms, RPC prioritizes\n              developer familiarity and productivity.\n              <br />\n              <br />\n              <p>{\">> Commandments of RPC\"}</p>\n              Here are some key principles that define the philosophy of RPC:\n                <br />\n                <br />\n              The illusion of locality. RPC abstracts the network, allowing\n              developers to focus on logic rather than infrastructure. This\n              mirrors Alan Kay’s principle: “Simple things should be simple.”\n              <br />\n              <br />\n              Action-oriented design. RPC emphasizes verbs over nouns—procedures\n              like calculateTax() or fetchUser(), unlike REST’s resource-centric\n              model (e.g., GET /users/123).\n              <br />\n              <br />\n              Contract-first design. RPC enforces strict method signatures\n              between clients and servers, ensuring type safety but creating\n              tight coupling. This favors precision and predictability over\n              flexibility.\n              <br />\n              <br />\n              Developer ergonomics. RPC frameworks like gRPC and Thrift optimize\n              for usability—offering code generation, IDE autocompletion, and\n              typed interfaces to reduce friction.\n              <br />\n              <br />\n              <p>{\">> Comparing it to REST\"}</p>\n              REST, as defined by Roy Fielding’s dissertation, enforces\n              architectural constraints (statelessness, uniform interface, etc.)\n              to improve scalability and resilience. Its philosophy treats the\n              network as a first-class citizen—embracing its complexities rather\n              than abstracting them away.\n              <br />\n              <br />\n              RPC, by contrast, treats the network as an implementation detail.\n              It aligns with the fallacies of distributed computing—recognizing\n              that developers often underestimate network complexity, so\n              abstraction is a necessary tool.\n              <br />\n              <br />\n              However, tight coupling and action-oriented design can become\n              liabilities in long-lived, evolving systems. REST’s\n              resource-oriented model often better accommodates change.\n              <br />\n              <br />\n              Whether you’re using REST, gRPC, or another RPC framework, the\n              core idea remains the same: invoking remote functionality over a\n              network. REST isn’t a fundamentally different paradigm—it’s just\n              an RPC style optimized for the web.\n              <br />\n              <br />\n              In a dusty archive, the original RPC RFC whispers: \"Hide the\n              network, but respect its chaos.\" Nearby, Roy Fielding’s REST\n              dissertation retorts: \"The network is your partner, not your\n              enemy.\"\n              <br />\n              And so, the balance remains.\n              <br />\n              <br />\n            </p>\n          </div>\n        </div>\n      </div>\n    </Layout>\n  );\n};\n\nexport default Page;\n"],"names":["_ref","heading","headingClass","bodyClass","sideComponent","sideImg","sideClass","className","sideImgClassName","id","children","React","styleVars","page","xl","Icon","name","props","isContactOpen","setContact","useState","Layout","headerClass","SEO","title","description","class","style","minHeight","SectionBox"],"sourceRoot":""}