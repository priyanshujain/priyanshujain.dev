{"version":3,"file":"component---src-pages-writings-level-of-error-handling-js-6a53cfbfba5abdfbc1c3.js","mappings":"6LAuCA,MAnCmBA,IAWZ,IAXa,QAClBC,EAAO,aACPC,EAAa,GAAE,UACfC,EAAU,GAAE,cACZC,EAAa,QACbC,EAAO,UACPC,EAAU,GAAE,UACZC,EAAU,GAAE,iBACZC,EAAiB,GAAE,GACnBC,EAAG,GAAE,SACLC,GACDV,EACC,OACEW,EAAAA,cAAA,OAAKJ,UAAWA,EAAWE,GAAIA,GAC7BE,EAAAA,cAAA,OAAKJ,UAAcK,EAAAA,EAAUC,KAAKC,GAAE,uCAClCH,EAAAA,cAAA,OAAKJ,UAAS,GAAKJ,GACjBQ,EAAAA,cAAA,MAAIJ,UAAS,GAAKL,GACfD,GAEFS,GAEFL,GAAWD,EACVO,EAAAA,cAAA,OAAKJ,UAAS,GAAKD,GAChBD,EACCM,EAAAA,cAACI,EAAAA,EAAI,CAACC,KAAMX,EAASE,UAAWC,IAEhCJ,GAGH,MAED,C,kFCiIV,UAtJca,IACZ,MAAM,EAACC,EAAc,EAACC,IAAcC,EAAAA,EAAAA,WAAS,GAQ7C,OACET,EAAAA,cAACU,EAAAA,EAAM,CAACC,YAAY,IAClBX,EAAAA,cAACY,EAAAA,EAAG,CACFC,MAAM,0BACNC,YAAW,kPACXC,MAAO,wBAETf,EAAAA,cAAA,OACEgB,MAAM,eACNC,MAAO,CACLC,UAAW,UAGblB,EAAAA,cAACmB,EAAAA,EAAU,CACT7B,QAAQ,0BACRC,aAAa,2CACbC,UAAU,uBACVI,UAAU,SAEZI,EAAAA,cAAA,OAAKJ,UAAU,4BACbI,EAAAA,cAAA,OAAKJ,UAAU,eACbI,EAAAA,cAAA,KAAGJ,UAAU,yCAAwC,kPAKnDI,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,sQAMNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,8TAONA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,sRAMNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,wKAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,q4BAeNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,kQAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,wUAONA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,4NAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,yeASNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,0SAMNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,yMAINA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,0SAMNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,0SAMNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,WAAM,yNAKNA,EAAAA,cAAA,WACAA,EAAAA,cAAA,eAKD,C","sources":["webpack://priyanshujain.dev/./src/components/home/SectionBox.js","webpack://priyanshujain.dev/./src/pages/writings/level-of-error-handling.js"],"sourcesContent":["import React from \"react\";\nimport Icon from \"../Icon\";\nimport styleVars from \"../../styles/style-vars\";\n\nconst SectionBox = ({\n  heading, \n  headingClass=\"\", \n  bodyClass=\"\", \n  sideComponent,\n  sideImg, \n  sideClass=\"\", \n  className=\"\",\n  sideImgClassName=\"\",\n  id=\"\",\n  children\n}) => {\n  return (\n    <div className={className} id={id}>\n      <div className={`${styleVars.page.xl} grid-12 gutter-row-20 gutter-36-ns`}>\n        <div className={`${bodyClass}`}>\n          <h1 className={`${headingClass}`}>\n            {heading}\n          </h1>\n          {children}\n        </div>\n        {sideImg || sideComponent ? (\n          <div className={`${sideClass}`}>\n            {sideImg ? (\n              <Icon name={sideImg} className={sideImgClassName}/>\n            ) : (\n              sideComponent\n            )}\n          </div>\n        ): null}\n      </div>\n    </div>\n  );\n}\n\nexport default SectionBox;\n","import React, { useState } from \"react\";\nimport Layout from \"../../components/layout/index\";\nimport SEO from \"../../components/seo\";\nimport { SectionBox } from \"../../components/home\";\nimport Icon from \"../../components/Icon\";\n\nconst handleScroll = (isModalOpen) => {\n  if (isModalOpen === true) {\n    document.documentElement.style.overflow = \"hidden\";\n  } else {\n    document.documentElement.style.overflowY = \"scroll\";\n  }\n};\n\nconst Page = (props) => {\n  const [isContactOpen, setContact] = useState(false);\n  const handleContact = () => {\n    // Look into state updates\n    // Look into state updates\n    handleScroll(!isContactOpen);\n    setContact(!isContactOpen);\n  };\n\n  return (\n    <Layout headerClass=\"\">\n      <SEO\n        title=\"Level of error handling\"\n        description={`How should I determine the level of error handling needed while building software, especially when interacting with multiple external systems? How many times should I retry after a failure? This is a stressful question for every developer.`}\n        image={\"/error-handling.png\"}\n      />\n      <div\n        class=\"main-content\"\n        style={{\n          minHeight: \"100vh\",\n        }}\n      >\n        <SectionBox\n          heading=\"Level of error handling\"\n          headingClass=\"ma0 pa0 f2 f-headline-ns sig-blue fw-600\"\n          bodyClass=\"col-12 mw-100 center\"\n          className=\"pt16\"\n        />\n        <div className=\" pt0 pb5 pt10-ns pb20-ns\">\n          <div className=\"mw-l center\">\n            <p className=\"ma0 pa0 pl5 pr5 mt4 f4 f3-ns sig-grey\">\n              How should I determine the level of error handling needed while\n              building software, especially when interacting with multiple\n              external systems? How many times should I retry after a failure?\n              This is a stressful question for every developer.\n              <br />\n              <br />\n              The answer isn't straightforward, and the decision-making process\n              can be stressful. Over-engineering error handling can lead to\n              unnecessary complexity, while under-engineering can expose your\n              system to vulnerabilities. So, how do you strike the right\n              balance?\n              <br />\n              <br />\n              The Nature of Failures: Transient vs. Persistent First, it’s\n              essential to understand the types of failures your system is\n              likely to encounter. Are these failures transient, such as brief\n              network issues or temporary service hiccups? Or are they\n              persistent, like an external service going down for an extended\n              period?\n              <br />\n              <br />\n              Understanding the nature of the failure informs how aggressive\n              your retry strategy should be. Transient failures might justify\n              several retry attempts, while persistent failures might need\n              different handling—such as alerting a human operator or switching\n              to a fallback system.\n              <br />\n              <br />\n              The Retry Conundrum: How Many Times? This brings us to the heart\n              of the dilemma: how many times should you retry an operation? The\n              answer depends on several factors:\n              <br />\n              <br />\n              Criticality of the Operation: If the operation is crucial—like\n              processing a payment—you might want to implement more retries with\n              exponential backoff to increase the likelihood of success. For\n              less critical operations, a single retry or none at all might\n              suffice. Exponential Backoff: This technique, where the delay\n              between retries increases exponentially, is a common strategy. It\n              gives the external system time to recover and reduces the risk of\n              overloading it with repeated requests. However, determining the\n              exact backoff interval can be tricky and may require fine-tuning\n              based on real-world conditions. Circuit Breaker Pattern: To avoid\n              overwhelming a failing service, you can use a circuit breaker\n              pattern. After a set number of failures, the circuit breaker\n              trips, and further attempts are halted temporarily. This approach\n              prevents your system from wasting resources on doomed operations.\n              <br />\n              <br />\n              Timeouts and Deadlines: Avoiding the Infinite Wait Time is another\n              crucial factor in error handling. Setting appropriate timeouts\n              ensures that your system doesn't hang indefinitely, waiting for a\n              response that may never come. But how long should you wait?\n              <br />\n              <br />\n              The timeout value should be informed by the typical response time\n              of the external service. Too short, and you risk cutting off\n              potentially successful operations; too long, and you could be\n              holding up other processes. A global deadline for a set of\n              operations can also help prevent cascading failures from causing\n              long delays.\n              <br />\n              <br />\n              Fallback Strategies: Preparing for the Worst No matter how\n              carefully you design your error handling, there will be times when\n              external systems fail beyond your control. That’s where fallback\n              strategies come into play.\n              <br />\n              <br />\n              Graceful Degradation: This might involve serving cached data,\n              switching to a secondary service, or providing a default response\n              to the user. The goal is to maintain functionality, even if it’s\n              limited, rather than failing outright. Idempotency: Ensuring that\n              retries are idempotent is crucial. This means that performing the\n              same operation multiple times won’t have unintended side\n              effects—like charging a customer twice. Idempotency is key to\n              making your retry logic safe and reliable.\n              <br />\n              <br />\n              Monitoring and Alerting: Eyes on the System To navigate the\n              uncertainty of error handling, real-time monitoring and alerting\n              are indispensable. By tracking the success and failure rates of\n              your system’s interactions with external services, you can\n              identify patterns and intervene when necessary.\n              <br />\n              <br />\n              Alerts: Set up alerts to notify you when retries exceed a certain\n              threshold or when failures are consistent over a period. This way,\n              you can step in before minor issues escalate into major problems.\n              <br />\n              <br />\n              The Final Word: There’s No One-Size-Fits-All The reality is that\n              error handling is as much an art as it is a science. Every system,\n              every external service, and every business requirement is\n              different. What works in one context may not work in another, and\n              that’s where the stress often comes in.\n              <br />\n              <br />\n              However, by understanding the nature of failures, employing smart\n              retry logic, setting appropriate timeouts, and having robust\n              fallback strategies, you can mitigate much of the uncertainty. The\n              key is to make informed decisions, continually monitor\n              performance, and be ready to adjust as needed.\n              <br />\n              <br />\n              In the end, while error handling will always involve some level of\n              stress, it’s also an opportunity to build resilient systems that\n              can weather the unexpected—turning potential pitfalls into mere\n              bumps in the road.\n              <br />\n              <br />\n            </p>\n          </div>\n        </div>\n      </div>\n    </Layout>\n  );\n};\n\nexport default Page;\n"],"names":["_ref","heading","headingClass","bodyClass","sideComponent","sideImg","sideClass","className","sideImgClassName","id","children","React","styleVars","page","xl","Icon","name","props","isContactOpen","setContact","useState","Layout","headerClass","SEO","title","description","image","class","style","minHeight","SectionBox"],"sourceRoot":""}